#ifndef NES_EMULATOR_H_
#define NES_EMULATOR_H_
#include "../nesPch.h"

#include "cpu/cpu6502debug.h"
#include "ppu/ppuDebug.h"

#include "inputOutput/IOInterface.h"
#include "cartridge/cartridge.h"
#include "frameBuffer.h"
#include "cpu/cpu6502.h"
#include "cpuBus.h"
#include "ppuBus.h"

namespace nesCore {
class NesEmulator {
public:
    NesEmulator();
    ~NesEmulator();

// Public methods
public:
    // Get a pointer to the emulator frame buffer
    FrameBuffer* getFrameBuffer();
    // Load a cartridge from a file
    // Return 0 on success, 1 if the file doesn't exit
    // and 2 if it has the wrong format
    int loadCartridge(const std::string& filename);
    // Attach an IO interface to the emulator
    void attachIO(IOInterface* interface);

    // Load the color palette from file
    // Return 0 on success, 1 if the file doesn't exit
    // and 2 if it has the wrong format
    int loadPalette(const std::string& filename);
    // Parse file header for iNES and NES 2
    CartridgeOption iNESparse(uint8_t* header);
    CartridgeOption NES2parse(uint8_t* header);

    // Execute one CPU instruction
    void step();
    
    // Return true if the PPU finished a frame
    bool frameReady();

    // Reset the emulator
    void reset();

    // Debug info
    //
    // Return a sting with a formatted region of the bus
    // Take a memory range as input (both extreme are included)
    std::string formatBusRange(uint16_t from, uint16_t to, uint width);
    // Decompile instruction
    std::string decompileInstruction(uint16_t addr);
    // Return CPU or PPU debug info
    debug::Cpu6502Debug cpuDebugInfo();
    debug::PPUDebug ppuDebugInfo();

// Private member variables
private:
    Bus m_cpuBus;
    PpuBus m_ppuBus;

    // Interrupt Generated by the PPU
    Interrupt6502 m_ppuInt;

    // The emulator frame buffer
    FrameBuffer m_frameBuffer;

    Cartridge* mp_cartridge;
};
}

#endif
